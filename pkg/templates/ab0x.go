// generaTed by fileb0x at "2017-07-07 21:58:36.79397925 +0200 CEST" from config file "ab0x.yaml"

package templates

import (
	"bytes"
	"compress/gzip"
	"io"
	"log"
	"net/http"
	"os"

	"golang.org/x/net/context"
	"golang.org/x/net/webdav"
)

var (
	// CTX is a context for webdav vfs
	CTX = context.Background()

	// FS is a virtual memory file system
	FS = webdav.NewMemFS()

	// Handler is used to server files through a http handler
	Handler *webdav.Handler

	// HTTP is the http file system
	HTTP http.FileSystem = new(HTTPFS)
)

// HTTPFS implements http.FileSystem
type HTTPFS struct{}

// FileLayoutTmpl is "./layout.tmpl"
var FileLayoutTmpl = []byte("\x1f\x8b\x08\x00\x00\x09\x6e\x88\x00\xff\x7c\xd2\xc1\x8e\xdb\x20\x10\x00\xd0\x73\xfc\x15\x94\x73\x08\x6a\x4f\x3d\x80\xa5\x2a\xcd\xa1\xa7\xf6\x90\x4a\xbb\x47\x82\xc7\x61\x36\x18\xbc\x30\x71\xd6\xb2\xfc\xef\x2b\xdb\x89\x76\xa5\x8d\x72\xb2\x87\x99\x79\x80\x06\xf5\xed\xf7\xdf\xed\xfe\xf9\xdf\x8e\x39\x6a\x7c\x59\x14\x6a\xfa\x32\x6f\xc2\x51\x73\x08\xbc\x2c\x56\xca\x81\xa9\xca\x62\xb5\x52\x0d\x90\x61\xd6\x99\x94\x81\x34\x3f\x53\x2d\x7e\xf2\x4f\x89\x18\x08\x02\x69\x7e\xc1\x8a\x9c\xae\xa0\x43\x0b\x62\x0e\xd6\x0c\x03\x12\x1a\x2f\xb2\x35\x1e\xf4\xf7\x35\xcb\x2e\x61\x38\x09\x8a\xa2\x46\xd2\x21\x72\x16\x4c\x03\x9a\x77\x08\x97\x36\x26\xba\x07\xff\xd9\x69\xa8\x8e\xc0\x99\x23\x6a\x05\xbc\x9e\xb1\xd3\xfc\x49\xfc\xff\x25\xb6\xb1\x69\x0d\xe1\xc1\x03\x2f\x8b\xaf\x8d\x37\xbc\x82\x6c\x13\xb6\x84\x31\xdc\xf3\x6f\x65\xe6\x4c\x2e\xa6\xab\x44\x48\x1e\xca\x61\x60\x9b\xfd\xf4\xc7\xc6\x51\xc9\x65\x6d\x4e\x7b\x0c\x27\x96\xc0\x6b\x8e\x36\x06\xce\x5c\x82\x5a\x73\x19\x27\xe3\x87\x68\x53\x7c\xeb\xa5\xc9\x19\x28\xcb\xda\x74\x53\xcd\x06\x6d\x5c\x76\xff\xe8\xcd\xd4\x7b\xc8\x0e\x80\x1e\x0a\x73\xb0\xb1\x39\x73\x26\xa7\xc9\xc8\xeb\x68\xd4\x21\x56\xfd\x44\x0e\x03\xeb\x11\x7c\xc5\xc6\x71\x3e\xdd\x72\x5d\x96\x93\x7d\x28\xbe\x64\x5e\x2a\xb9\x14\xcf\xee\xe2\x29\xb9\x3c\x8a\xf7\x00\x00\x00\xff\xff\x83\x12\x5f\xde\x25\x02\x00\x00")

// FileLoginTmpl is "./login.tmpl"
var FileLoginTmpl = []byte("\x1f\x8b\x08\x00\x00\x09\x6e\x88\x00\xff\xbc\x54\xc1\x8e\xdc\x2a\x10\x3c\x7b\xbf\x02\x71\xe7\x59\xfb\xf6\x6a\xcf\x3d\xb7\x48\x49\x3e\xa0\x07\xda\x63\xb4\x98\x46\xd0\x9e\xdd\xc9\x6a\xff\x3d\x32\x60\x8b\x99\x1c\x13\xe5\xe4\xea\xae\xee\xa2\x28\x24\x0f\xc6\x5e\x85\x76\x90\xd2\x28\xd7\x57\x35\x39\x7c\x17\xf5\xab\x34\x7a\xc6\x28\x4f\x4f\xdd\xc3\x94\x86\x68\x44\xfd\x2a\x83\x13\xac\x8e\x8f\x7a\xa6\x2b\xc6\xa3\x3a\x93\xb9\x6d\x0a\xdd\x30\xbf\x34\x0a\x33\x82\xb1\xfe\xa2\x9c\xf5\x98\xe9\x6e\x48\x01\x7c\x46\xdd\xc7\x87\xf8\xef\xbb\x65\x87\xe2\xf3\x33\x53\xfd\xce\x0d\xfd\xfc\x72\x7a\xda\xc0\xbd\x21\x70\x18\x59\x19\xf0\x17\x8c\x52\xec\x8d\xa2\x0b\xbf\xcd\x69\x47\x09\xf3\x58\x46\xa7\xa1\x87\x2c\xda\x0d\xa1\x18\xf8\xe2\x35\xc5\x88\x9a\xc5\x9a\x30\x7a\x58\x50\x50\x14\x01\x52\x7a\xa3\x68\x8a\xa5\x50\xfc\x18\x7b\x2d\x86\x26\x8a\x4b\x1b\x24\xc5\x45\x25\x06\xfd\x8a\x46\x8a\x05\x79\x26\x33\xca\x40\x89\xa5\x00\xcd\x96\xfc\x28\x7b\x82\x95\xe7\xff\x55\x88\xf4\x7e\xeb\x37\x5c\xa3\xb8\xbf\xdc\x02\xf1\x62\x7d\xa1\xba\xc1\xc1\x19\xdd\xe3\x41\xb9\x29\xc5\x44\x71\x94\xbb\xe5\xba\xd0\xfd\xa8\x75\x59\xef\xf3\x68\xd5\x7a\x78\xfb\x4d\x49\x93\xe7\x48\x2e\xed\xdb\x83\xf5\x61\xe5\x66\x2a\xd7\x52\x58\xd3\x9c\x24\xf8\x16\xb0\xa9\xcb\x6a\x07\x2b\xd3\x44\x7a\x4d\xa3\x3c\x60\xcb\x69\x08\x96\xc1\xd9\x9f\x38\x4a\x9a\xa6\x3b\xaa\xe4\x5f\xfa\xd5\x6d\xc9\xba\x6b\x53\xff\xc3\xa8\xf6\x17\xdd\x2f\xfb\xb5\x79\xe1\xbf\x17\x55\x09\xe7\x38\x2b\x47\x77\x54\xff\x30\x8e\xf3\xca\x4c\xbe\xa1\x6b\xe3\x40\x2a\x44\xbb\x40\xbc\x6d\x9d\x37\x6b\x78\x56\xcf\xea\x59\x1c\x3a\x2a\x2d\xe0\x9c\x3a\x13\x33\x2d\xfb\xa5\xbf\xd9\x8b\x17\xd6\x57\x4b\x45\xa7\x75\xb5\x81\x2d\xad\xed\x27\x52\x3a\xf5\xf3\x2b\x00\x00\xff\xff\x5d\x7b\xf5\x86\x79\x04\x00\x00")

func init() {
	if CTX.Err() != nil {
		log.Fatal(CTX.Err())
	}

	var err error

	var f webdav.File

	var rb *bytes.Reader
	var r *gzip.Reader

	rb = bytes.NewReader(FileLayoutTmpl)
	r, err = gzip.NewReader(rb)
	if err != nil {
		log.Fatal(err)
	}

	err = r.Close()
	if err != nil {
		log.Fatal(err)
	}

	f, err = FS.OpenFile(CTX, "./layout.tmpl", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0777)
	if err != nil {
		log.Fatal(err)
	}

	_, err = io.Copy(f, r)
	if err != nil {
		log.Fatal(err)
	}

	err = f.Close()
	if err != nil {
		log.Fatal(err)
	}

	rb = bytes.NewReader(FileLoginTmpl)
	r, err = gzip.NewReader(rb)
	if err != nil {
		log.Fatal(err)
	}

	err = r.Close()
	if err != nil {
		log.Fatal(err)
	}

	f, err = FS.OpenFile(CTX, "./login.tmpl", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0777)
	if err != nil {
		log.Fatal(err)
	}

	_, err = io.Copy(f, r)
	if err != nil {
		log.Fatal(err)
	}

	err = f.Close()
	if err != nil {
		log.Fatal(err)
	}

	Handler = &webdav.Handler{
		FileSystem: FS,
		LockSystem: webdav.NewMemLS(),
	}
}

// Open a file
func (hfs *HTTPFS) Open(path string) (http.File, error) {
	f, err := FS.OpenFile(CTX, path, os.O_RDONLY, 0644)
	if err != nil {
		return nil, err
	}

	return f, nil
}

// ReadFile is adapTed from ioutil
func ReadFile(path string) ([]byte, error) {
	f, err := FS.OpenFile(CTX, path, os.O_RDONLY, 0644)
	if err != nil {
		return nil, err
	}

	buf := bytes.NewBuffer(make([]byte, 0, bytes.MinRead))

	// If the buffer overflows, we will get bytes.ErrTooLarge.
	// Return that as an error. Any other panic remains.
	defer func() {
		e := recover()
		if e == nil {
			return
		}
		if panicErr, ok := e.(error); ok && panicErr == bytes.ErrTooLarge {
			err = panicErr
		} else {
			panic(e)
		}
	}()
	_, err = buf.ReadFrom(f)
	return buf.Bytes(), err
}

// WriteFile is adapTed from ioutil
func WriteFile(filename string, data []byte, perm os.FileMode) error {
	f, err := FS.OpenFile(CTX, filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)
	if err != nil {
		return err
	}
	n, err := f.Write(data)
	if err == nil && n < len(data) {
		err = io.ErrShortWrite
	}
	if err1 := f.Close(); err == nil {
		err = err1
	}
	return err
}

// FileNames is a list of files included in this filebox
var FileNames = []string{
	"./layout.tmpl",
	"./login.tmpl",
}
