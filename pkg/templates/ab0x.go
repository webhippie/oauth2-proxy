// Code generated by fileb0x at "2017-10-26 21:32:48.854462079 +0200 CEST m=+0.003369763" from config file "ab0x.yaml" DO NOT EDIT.

package templates

import (
	"bytes"
	"compress/gzip"
	"io"
	"log"
	"net/http"
	"os"
	"path"

	"golang.org/x/net/context"
	"golang.org/x/net/webdav"
)

var (
	// CTX is a context for webdav vfs
	CTX = context.Background()

	// FS is a virtual memory file system
	FS = webdav.NewMemFS()

	// Handler is used to server files through a http handler
	Handler *webdav.Handler

	// HTTP is the http file system
	HTTP http.FileSystem = new(HTTPFS)
)

// HTTPFS implements http.FileSystem
type HTTPFS struct{}

// FileLayoutTmpl is "layout.tmpl"
var FileLayoutTmpl = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\x7c\xd2\xb1\x6e\xdb\x30\x10\x00\xd0\xd9\xfa\x0a\x96\xb3\x69\xa2\x9d\x3a\x90\x02\x0a\xd7\x43\xa7\x76\x70\x81\x64\xa4\xa9\x93\x79\x31\x45\x2a\xe4\x59\x8e\x20\xe8\xdf\x03\x49\x36\x12\x20\x86\x27\xe9\x78\x77\xef\x40\x1c\xd5\xb7\xdf\x7f\xb7\xfb\xe7\x7f\x3b\xe6\xa8\xf1\x65\x51\xa8\xe9\xcb\xbc\x09\x47\xcd\x21\xf0\xb2\x58\x29\x07\xa6\x2a\x8b\xd5\x4a\x35\x40\x86\x59\x67\x52\x06\xd2\xfc\x4c\xb5\xf8\xc9\x3f\x25\x62\x20\x08\xa4\xf9\x05\x2b\x72\xba\x82\x0e\x2d\x88\x39\x58\x33\x0c\x48\x68\xbc\xc8\xd6\x78\xd0\xdf\xd7\x2c\xbb\x84\xe1\x24\x28\x8a\x1a\x49\x87\xc8\x59\x30\x0d\x68\xde\x21\x5c\xda\x98\xe8\x1e\xfc\x67\xa7\xa1\x3a\x02\x67\x8e\xa8\x15\xf0\x7a\xc6\x4e\xf3\x27\xf1\xff\x97\xd8\xc6\xa6\x35\x84\x07\x0f\xbc\x2c\xbe\x36\xde\xf0\x0a\xb2\x4d\xd8\x12\xc6\x70\xcf\xbf\x95\x99\x33\xb9\x98\xae\x12\x21\x79\x28\x87\x81\x6d\xf6\xd3\x1f\x1b\x47\x25\x97\xb3\x39\xed\x31\x9c\x58\x02\xaf\x39\xda\x18\x38\x73\x09\x6a\xcd\x65\x9c\x8c\x1f\xa2\x4d\xf1\xad\x97\x26\x67\xa0\x2c\x6b\xd3\x4d\x35\x1b\xb4\x71\x99\xfe\xd1\x9b\xa9\xf7\x90\x1d\x00\x3d\x14\xe6\x60\x63\x73\xe6\x4c\x4e\x9b\x91\xd7\xd5\xa8\x43\xac\xfa\x89\x1c\x06\xd6\x23\xf8\x8a\x8d\xe3\x34\x60\xb9\x2d\xcb\xc9\x3e\x04\x5f\x32\x2f\x95\x5c\x8a\x67\x76\xe1\x94\x5c\xde\xc4\x7b\x00\x00\x00\xff\xff\x50\x26\x33\x5a\x24\x02\x00\x00")

// FileLoginTmpl is "login.tmpl"
var FileLoginTmpl = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xac\x96\xc1\x8e\xe3\x36\x0f\xc7\xcf\x99\xa7\x20\xf4\x01\x5f\x2f\xeb\xa4\x33\x97\x02\xd3\x24\xc0\x6e\x51\x4c\xe7\x50\xb4\x87\xb9\x17\xb4\x45\x5b\x6a\x64\xd1\x95\xe8\x64\x8d\xc5\xbe\x7b\x21\xc9\xc9\x64\x92\xcc\x65\xbb\x97\x58\x22\x25\xf2\x27\xea\x6f\x3a\x6b\x6d\xf7\xd0\x38\x8c\x71\xa3\xc6\x5d\x65\xc8\x76\x46\xaa\xfb\xea\x1e\xc6\x5d\xd5\x3a\xfa\x7c\x7c\x56\x0d\x79\xa1\x70\x9a\xf6\x56\x6b\x47\x6a\x7b\xb7\xb8\x08\xd1\x60\xd0\x30\x3f\x2b\x4d\x2d\x8e\x4e\x4e\x73\xc3\xfb\x12\x23\xcf\x6a\xd6\x53\x8a\xb0\x58\x9b\xfb\x8b\x08\x95\x58\x71\xa4\xc0\x58\xad\xc9\xa7\x35\x8b\x2f\x5f\x60\xf9\x92\xac\xf0\xf5\x6b\xda\xb3\x32\xf7\xdb\xbb\xbb\x6c\xb7\x2d\x78\x82\xe5\xaf\x21\x70\x00\xa5\xca\x82\x4b\x30\x74\x14\xa4\xd2\xe8\x3b\x0a\x0a\x8e\x86\x1c\x7a\xb1\x1e\xca\x33\x27\x29\x61\x4a\x8c\xc5\x7a\x55\x5c\xeb\x95\xb6\xfb\x6d\x49\x47\x5e\x27\xf7\xdd\x55\x8a\x01\xb5\xb6\xbe\x83\xd7\x61\x15\xa8\xe7\x3d\x55\x8e\x5a\xb9\x61\x0e\xa9\xdc\x6a\x7b\x83\xb6\x1e\x45\xd8\x57\x5d\xe0\x71\x50\x33\x24\x5e\xf9\xe1\x75\xe5\x5c\x6a\x05\x26\x50\xbb\x51\x2b\xc6\x51\xcc\x43\x35\x04\xfe\x3c\xad\x3a\x2b\x66\xac\xe7\x38\x8b\xb5\xed\xbb\x63\xa8\x21\xf0\xde\xea\x54\x91\x18\x9a\xcb\x6d\x18\x23\x49\x9c\x77\x2f\xe3\xbe\x53\x80\x4e\x36\xea\x18\xe8\xc9\xca\x6f\x63\x3d\xd7\x09\xbf\x07\xa5\xc3\xff\x42\xe9\xf0\x1d\x4a\x87\xdf\x8f\xb2\xb6\x52\x8f\xcd\x8e\xe4\x5b\x41\x4f\x01\x6e\xb0\x7e\x3a\xfa\xde\xe0\x9e\xc4\x37\x0f\xd2\xa8\xa0\x26\xef\x99\xfe\x38\x5a\xb1\xec\xab\x9a\x45\xb8\x2f\xf2\x3a\x97\x5d\xec\xd1\x39\x95\x36\x8d\xbb\xca\x36\xec\x37\x2a\xfd\x3e\x82\xf5\x2d\x1f\xed\xc2\x5d\xe7\x68\xa3\x04\x43\x47\xf2\x08\xff\x3b\x39\x65\x1a\x68\xa3\x4a\x66\xb5\x5d\xaf\xca\x28\xf5\x80\xc2\x75\xc4\xcb\x5a\xb6\x7a\xa3\xf2\xce\x04\xd0\xb3\x46\x77\xdd\x2c\xb2\xb9\xd2\x16\x1d\x77\xa5\x13\xdc\xf2\x1b\xc2\x54\xd2\x52\x0a\xf3\x70\xe5\x2f\xbd\xa2\x54\xf0\xd9\xb7\x1c\x7a\x4c\x55\x28\x95\x33\x0f\x17\x85\xbb\x95\x21\x77\xa2\xc4\x99\xfa\x53\xeb\xf8\x50\xe1\x28\x5c\x12\xce\xad\x61\x1d\x25\xb0\xef\xe6\x7b\xfa\x85\x87\xa9\x54\xf7\xff\x0d\x0f\xd3\xcf\xf0\xf0\xe3\xfd\x4f\xf0\x62\xb8\xc7\x08\x9f\x98\x42\x47\x61\x09\x1f\x9d\x83\xbc\x2a\x42\xa0\x48\x61\x4f\x7a\x09\xbf\xa3\x26\x38\x58\x31\x30\x8c\x81\x60\x1d\x07\xcc\xda\x3b\xbf\x0e\x43\x18\x24\x55\x38\x39\xb7\x60\x3d\x3c\x51\xe8\xd1\x4f\xcb\x59\x17\x67\x30\xb9\x43\x9d\x93\xbe\x18\x1b\x41\x98\x1d\xd8\x08\x03\x1f\x28\x90\x86\x7a\x02\x31\x04\x6b\x9c\x35\x6d\x44\x86\xf8\xb8\x3a\xbe\xdb\x0d\xf7\xab\x03\xd5\xc6\x0e\x83\xa5\x37\xaa\x55\x50\x74\xb0\x51\x7f\xd5\x0e\xfd\x4e\x6d\xff\xf8\x98\xbc\xf0\x67\xf2\x26\x85\x82\x30\xcc\xba\x07\x84\xc8\xce\x6a\x48\x01\xc8\x8b\x6d\xf2\x4d\xa4\x15\xb4\xa7\x30\xc1\x81\x6a\xc0\x61\x70\xb3\x63\x09\xcf\x2d\x4c\x3c\x42\x6b\xbd\x06\xf4\x13\xd8\x18\x47\xca\xa6\x06\x3d\x04\x1a\x38\x08\x58\x01\xf6\xdf\xc0\xbe\xca\xd1\xe2\xf5\x11\x78\x0c\x73\x26\x09\xd8\xec\x28\xa4\x73\x7c\x48\xdf\x91\x94\xf9\xef\x31\x0a\x74\x2c\x80\xf0\xcf\x48\x31\x9f\x20\x69\x10\xf2\xd7\x4b\x18\xd2\xf6\xc6\xa0\x40\x60\xee\xdf\x43\x13\x0a\x4b\x7b\x4e\xd6\x91\xa7\x80\xee\x9a\xe6\x29\x2f\x4e\x08\xcb\x9b\x17\xfa\x7c\x81\x55\x4e\x95\x40\xce\xca\x4c\xd0\x72\xc8\x77\x1c\x28\x53\x93\x86\x24\x39\xdb\x10\x0c\x8e\x30\x12\x74\x24\x49\x4a\xc2\x63\x63\x8a\x02\xa7\x74\x12\xd4\xbd\xf5\x36\x4a\x40\xe1\xf0\x01\x9e\x7f\xe8\x21\x26\x65\xa6\x9c\x3b\xcf\x07\x30\x7c\x48\xc9\x1a\xf6\x82\x8d\x80\xb1\xfd\x2b\xe7\x8d\x9e\x74\xf5\x76\x35\x8e\x23\xbd\x36\xd5\x37\x5d\x24\xff\x19\x48\xfe\xf7\xdb\xc9\xbf\x01\x00\x00\xff\xff\x66\x38\x29\x42\xa4\x08\x00\x00")

func init() {
	if CTX.Err() != nil {
		log.Fatal(CTX.Err())
	}

	var err error

	var f webdav.File

	var rb *bytes.Reader
	var r *gzip.Reader

	rb = bytes.NewReader(FileLayoutTmpl)
	r, err = gzip.NewReader(rb)
	if err != nil {
		log.Fatal(err)
	}

	err = r.Close()
	if err != nil {
		log.Fatal(err)
	}

	f, err = FS.OpenFile(CTX, "layout.tmpl", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0777)
	if err != nil {
		log.Fatal(err)
	}

	_, err = io.Copy(f, r)
	if err != nil {
		log.Fatal(err)
	}

	err = f.Close()
	if err != nil {
		log.Fatal(err)
	}

	rb = bytes.NewReader(FileLoginTmpl)
	r, err = gzip.NewReader(rb)
	if err != nil {
		log.Fatal(err)
	}

	err = r.Close()
	if err != nil {
		log.Fatal(err)
	}

	f, err = FS.OpenFile(CTX, "login.tmpl", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0777)
	if err != nil {
		log.Fatal(err)
	}

	_, err = io.Copy(f, r)
	if err != nil {
		log.Fatal(err)
	}

	err = f.Close()
	if err != nil {
		log.Fatal(err)
	}

	Handler = &webdav.Handler{
		FileSystem: FS,
		LockSystem: webdav.NewMemLS(),
	}

}

// Open a file
func (hfs *HTTPFS) Open(path string) (http.File, error) {
	f, err := FS.OpenFile(CTX, path, os.O_RDONLY, 0644)
	if err != nil {
		return nil, err
	}

	return f, nil
}

// ReadFile is adapTed from ioutil
func ReadFile(path string) ([]byte, error) {
	f, err := FS.OpenFile(CTX, path, os.O_RDONLY, 0644)
	if err != nil {
		return nil, err
	}

	buf := bytes.NewBuffer(make([]byte, 0, bytes.MinRead))

	// If the buffer overflows, we will get bytes.ErrTooLarge.
	// Return that as an error. Any other panic remains.
	defer func() {
		e := recover()
		if e == nil {
			return
		}
		if panicErr, ok := e.(error); ok && panicErr == bytes.ErrTooLarge {
			err = panicErr
		} else {
			panic(e)
		}
	}()
	_, err = buf.ReadFrom(f)
	return buf.Bytes(), err
}

// WriteFile is adapTed from ioutil
func WriteFile(filename string, data []byte, perm os.FileMode) error {
	f, err := FS.OpenFile(CTX, filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)
	if err != nil {
		return err
	}
	n, err := f.Write(data)
	if err == nil && n < len(data) {
		err = io.ErrShortWrite
	}
	if err1 := f.Close(); err == nil {
		err = err1
	}
	return err
}

// WalkDirs looks for files in the given dir and returns a list of files in it
// usage for all files in the b0x: WalkDirs("", false)
func WalkDirs(name string, includeDirsInList bool, files ...string) ([]string, error) {
	f, err := FS.OpenFile(CTX, name, os.O_RDONLY, 0)
	if err != nil {
		return nil, err
	}

	fileInfos, err := f.Readdir(0)
	f.Close()
	if err != nil {
		return nil, err
	}

	for _, info := range fileInfos {
		filename := path.Join(name, info.Name())

		if includeDirsInList || !info.IsDir() {
			files = append(files, filename)
		}

		if info.IsDir() {
			files, err = WalkDirs(filename, includeDirsInList, files...)
			if err != nil {
				return nil, err
			}
		}
	}

	return files, nil
}
